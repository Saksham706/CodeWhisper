import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../context/AuthContext";
import "../styles/auth.css";

export default function Login() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const { login } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    if (!email || !password) {
      setError("Email and password are required");
      setLoading(false);
      return;
    }

    try {
      const res = await fetch("http://localhost:5000/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "Invalid email or password");
        setLoading(false);
        return;
      }

      login(data.token);
      navigate("/dashboard");
    } catch (err) {
      setError("Server error. Please try again later.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="auth-page">
      <form className="auth-card" onSubmit={handleSubmit}>
        <div className="auth-logo">
          <img src="/Nlogo.png" alt="CodeWhisper" />
        </div>

        <h2>Sign in</h2>

        {error && <div className="auth-error">{error}</div>}

        <input
          type="email"
          placeholder="Email address"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />

        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />

        <div className="auth-forgot">
          <span>Forgot password?</span>
        </div>

        <button type="submit" className="primary-btn" disabled={loading}>
          {loading ? "Signing in..." : "Enter CodeWhisper"}
        </button>

        <div className="auth-divider">
          <span>OR</span>
        </div>

        <button
          type="button"
          className="google-btn"
          onClick={() => alert("Google login coming soon")}
        >
          <img src="/google.png" alt="Google" />
          Continue with Google
        </button>

        <p className="auth-switch">
          New to CodeWhisper?{" "}
          <span onClick={() => navigate("/signup")}>Create account</span>
        </p>
      </form>
    </div>
  );
}
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import "../styles/auth.css";

export default function Signup() {
  const [form, setForm] = useState({
    firstName: "",
    lastName: "",
    countryCode: "+91",
    phone: "",
    email: "",
    password: "",
    confirmPassword: "",
  });

  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();

  const handleChange = (e) => {
    setForm({ ...form, [e.target.name]: e.target.value });
  };

  const submit = async (e) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    if (form.password !== form.confirmPassword) {
      setError("Passwords do not match");
      setLoading(false);
      return;
    }

    const payload = {
      ...form,
      phone: `${form.countryCode}${form.phone}`,
    };

    try {
      const res = await fetch("http://localhost:5000/api/auth/signup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "Signup failed");
        return;
      }

      navigate("/");
    } catch {
      setError("Server error. Try again later.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="auth-page">
      <form className="auth-card" onSubmit={submit}>
        <h2>Create account</h2>

        {error && <div className="auth-error">{error}</div>}

        <input name="firstName" placeholder="First Name" onChange={handleChange} />
        <input name="lastName" placeholder="Last Name" onChange={handleChange} />

        {/* üì± Phone Input with Country Code */}
        <div className="phone-group">
          <select
            name="countryCode"
            value={form.countryCode}
            onChange={handleChange}
          >
            <option value="+91">üáÆüá≥ +91</option>
            <option value="+1">üá∫üá∏ +1</option>
            <option value="+44">üá¨üáß +44</option>
            <option value="+61">üá¶üá∫ +61</option>
          </select>

          <input
            type="tel"
            name="phone"
            placeholder="Phone number"
            value={form.phone}
            onChange={handleChange}
          />
        </div>

        <input name="email" placeholder="Email Address" onChange={handleChange} />

        <input
          type="password"
          name="password"
          placeholder="Password"
          onChange={handleChange}
        />

        <input
          type="password"
          name="confirmPassword"
          placeholder="Confirm Password"
          onChange={handleChange}
        />

        <button className="primary-btn" disabled={loading}>
          {loading ? "Creating account..." : "Start Building with AI"}
        </button>

        <p className="auth-switch">
          Already inside?{" "}
          <span onClick={() => navigate("/login")}>Sign in</span>
        </p>
      </form>
    </div>
  );
}
import Editor from "@monaco-editor/react";
import { useWorkspace } from "../../context/WorkspaceContext";
import { LANGUAGE_META } from "../../config/languages";
import "../../styles/editor.css";

export default function CodeEditor() {
  const { activeFile, fileContents, updateContent } = useWorkspace();

  if (!activeFile) {
    return <div className="editor-empty">Open a file to start coding</div>;
  }

  const ext = activeFile.split(".").pop();
  const meta = LANGUAGE_META[ext] || {};

  return (
    <Editor
      theme="vs-dark"
      language={meta.monaco || "plaintext"}
      value={fileContents[activeFile] || ""}
      height="100%"
      options={{
        fontSize: 14,
        minimap: { enabled: false },
        automaticLayout: true,
      }}
      onMount={(editor) => {
        editor.onDidChangeModelContent(() => {
          const value = editor.getValue();
          updateContent(activeFile, value);
        });
      }}
    />
  );
}
import { useWorkspace } from "../../context/WorkspaceContext";
import "../../styles/editor.css";
export default function EditorTabs() {
  const { openTabs, activeFile, openFile, closeTab, dirtyFiles } =
    useWorkspace();

  return (
    <div className="tabs-bar">
      {openTabs.map((file) => (
        <div
          key={file}
          className={`tab ${activeFile === file ? "active" : ""}`}
          onClick={() => openFile(file)}
        >
          {file}
          {dirtyFiles.has(file) && <span className="dirty-dot">‚óè</span>}
          <span
            className="close"
            onClick={(e) => {
              e.stopPropagation();
              closeTab(file);
            }}
          >
            ‚úï
          </span>
        </div>
      ))}
    </div>
  );
}
import { useWorkspace } from "../../context/WorkspaceContext";
import { LANGUAGE_META } from "../../config/languages";
import "../../styles/editor.css";

export default function RunBar() {
  const {
    runCode,
    runProject,
    activeFile,
    refreshPreview,
    saveActiveFile,
    dirtyFiles,
  } = useWorkspace();

  const isProject = !activeFile;
  const isHTML = activeFile?.endsWith(".html");
  const isDirty = activeFile && dirtyFiles.has(activeFile);

  const ext = activeFile?.split(".").pop();
  const meta = LANGUAGE_META[ext] || {};

  const handleRun = () => {
    if (isProject) {
      runProject();
    } else if (isHTML) {
      refreshPreview();
    } else {
      runCode();
    }
  };

  return (
    <div className="run-bar">
      {/* LEFT */}
      <div className="run-bar-left">
        <span
          className={`lang-badge ${isProject ? "project" : ""}`}
          style={!isProject && meta.color ? { background: meta.color } : {}}
        >
          {isProject
            ? "Project"
            : isHTML
            ? "HTML"
            : meta.label || "Text"}
        </span>
      </div>

      {/* RIGHT */}
      <div className="run-bar-right">
        {/* SAVE BUTTON */}


        {/* RUN / PREVIEW BUTTON */}
        <button className="run-btn" onClick={handleRun}>
          ‚ñ∂{" "}
          {isProject
            ? "Run Project"
            : isHTML
            ? "Preview HTML"
            : "Run File"}
        </button>
      </div>
    </div>
  );
}
import { useWorkspace } from "../../context/WorkspaceContext";
import TreeNode from "./TreeNode";

export default function FileExplorer() {
  const { tree, createRequest } = useWorkspace();

  if (!tree) return null;

  return (
    <div className="file-explorer">
      {createRequest && (
        <TreeNode
          node={{
            name: "",
            type: createRequest.type,
            isNew: true,
          }}
          path={createRequest.parent}
        />
      )}

      {tree.children?.map((child) => (
        <TreeNode key={child.name} node={child} path="" />
      ))}
    </div>
  );
}
import { useState, useRef, useEffect } from "react";
import { useWorkspace } from "../../context/WorkspaceContext";
import { LANGUAGE_META } from "../../config/languages";
import "../../styles/explorer.css";

export default function TreeNode({ node, path }) {
  const [open, setOpen] = useState(true);
  const [editing, setEditing] = useState(false);
  const [tempName, setTempName] = useState(node.name);
  const [creating, setCreating] = useState(null);

  const inputRef = useRef(null);

  const {
    openFile,
    addFile,
    addFolder,
    renameNode,
    deleteNode,
    activeFile,
    dirtyFiles,
    setCreateRequest
  } = useWorkspace();

   if (node.name === ".workspace.json") {
    return null;
  }
  
  // ‚úÖ VS CODE STYLE PATH
  const currentPath = path ? `${path}/${node.name}` : node.name;

  const isActive =
    node.type === "file" && activeFile === currentPath;

  const isDirty = dirtyFiles.has(currentPath);

  const ext = node.name.split(".").pop();
  const meta = LANGUAGE_META[ext];

  /* AUTO FOCUS */
  useEffect(() => {
    if ((editing || creating) && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [editing, creating]);

  const submitRename = () => {
    if (tempName && tempName !== node.name) {
      renameNode(currentPath, tempName);
    }
    setEditing(false);
  };

  const cancelRename = () => {
    setTempName(node.name);
    setEditing(false);
  };

  if (node.isNew) {
  return (
    <div className="tree-row creating">
      <span className="file-indent" />
      <input
        ref={inputRef}
        className="rename-input"
        placeholder={
          node.type === "file" ? "newFile.ext" : "newFolder"
        }
        onKeyDown={(e) => {
          if (e.key === "Enter" && e.target.value.trim()) {
            node.type === "file"
              ? addFile(path, e.target.value.trim())
              : addFolder(path, e.target.value.trim());
            setCreateRequest(null);
          }
          if (e.key === "Escape") setCreateRequest(null);
        }}
        autoFocus
      />
    </div>
  );
}

  /* ===================== FOLDER ===================== */
  if (node.type === "folder") {
    return (
      <div className="tree-node">
        <div className="tree-row folder">
          <div
            className="tree-left"
            onClick={() => !editing && setOpen(!open)}
          >
            <span className="arrow">{open ? "‚ñº" : "‚ñ∂"}</span>
            <span className="icon folder-icon" />

            {editing ? (
              <input
                ref={inputRef}
                className="rename-input"
                value={tempName}
                onChange={(e) => setTempName(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") submitRename();
                  if (e.key === "Escape") cancelRename();
                }}
                onBlur={cancelRename}
              />
            ) : (
              <span className="name">{node.name}</span>
            )}
          </div>

          {!editing && (
            <div className="tree-actions">
              <button onClick={() => setCreating("file")}>ÔºãüìÑ</button>
              <button onClick={() => setCreating("folder")}>ÔºãüìÅ</button>
              <button onClick={() => setEditing(true)}>‚úé</button>
              <button onClick={() => deleteNode(currentPath)}>üóë</button>
            </div>
          )}
        </div>

        {/* INLINE CREATE */}
        {creating && (
          <div className="tree-row creating">
            <span className="file-indent" />
            <input
              ref={inputRef}
              className="rename-input"
              placeholder={creating === "file" ? "newFile.ext" : "newFolder"}
              onKeyDown={(e) => {
                if (e.key === "Enter" && e.target.value.trim()) {
                  creating === "file"
                    ? addFile(currentPath, e.target.value.trim())
                    : addFolder(currentPath, e.target.value.trim());
                  setCreating(null);
                  setOpen(true);
                }
                if (e.key === "Escape") setCreating(null);
              }}
              onBlur={() => setCreating(null)}
            />
          </div>
        )}

        {open &&
          node.children?.map((child) => (
            <TreeNode
              key={child.name}
              node={child}
              path={currentPath}
            />
          ))}
      </div>
    );
  }

  /* ===================== FILE ===================== */
  return (
    <div
      className={`tree-row file ${isActive ? "active" : ""}`}
      onClick={() => !editing && openFile(currentPath)}
    >
      <span className="file-indent" />

      {meta?.icon ? (
        <img src={meta.icon} alt={meta.label} className="file-icon-img" />
      ) : (
        <span className="icon file-icon" />
      )}

      {editing ? (
        <input
          ref={inputRef}
          className="rename-input"
          value={tempName}
          onChange={(e) => setTempName(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") submitRename();
            if (e.key === "Escape") cancelRename();
          }}
          onBlur={cancelRename}
        />
      ) : (
        <span className="name">
          {node.name}
          {isDirty && <span className="dirty-dot">‚óè</span>}
        </span>
      )}

      {!editing && (
        <div className="tree-actions">
          <button
            onClick={(e) => {
              e.stopPropagation();
              setEditing(true);
            }}
          >
            ‚úé
          </button>
          <button
            onClick={(e) => {
              e.stopPropagation();
              deleteNode(currentPath);
            }}
          >
            üóë
          </button>
        </div>
      )}
    </div>
  );
}
import { useState, useRef, useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import {
  FiFolder,
  FiTerminal,
  FiMoreVertical,
  FiLogOut,
  FiRefreshCcw,
  FiHome,
} from "react-icons/fi";
import { FaRobot } from "react-icons/fa";

import { useWorkspace } from "../../context/WorkspaceContext";
import { useAuth } from "../../context/AuthContext";
import "../../styles/navbar.css";

export default function Navbar() {
  const navigate = useNavigate();
  const location = useLocation();
  const { openNewTerminal, terminals, killTerminal } = useWorkspace();
  const { logout } = useAuth();

  const [open, setOpen] = useState(false);
  const menuRef = useRef(null);

  useEffect(() => {
    const handler = (e) => {
      if (menuRef.current && !menuRef.current.contains(e.target)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handler);
    return () => document.removeEventListener("mousedown", handler);
  }, []);

  const closeAllTerminals = () => {
    terminals.forEach((t) => killTerminal(t.id));
    setOpen(false);
  };

  return (
    <header className="navbar">
      {/* LEFT */}
      <div
        className="navbar-left"
        onClick={() => navigate("/dashboard")}
      >
        <img src="/Nlogo.png" alt="CodeWhisper" className="logo-img" />
      </div>

      {/* CENTER */}
      <nav className="navbar-center">
        <div
          className={`nav-tab ${
            location.pathname === "/dashboard" ? "active" : ""
          }`}
          onClick={() => navigate("/dashboard")}
        >
          <FiFolder />
          <span>Files</span>
        </div>

        <div className="nav-tab" onClick={openNewTerminal}>
          <FiTerminal />
          <span>Terminal</span>
        </div>

        <div className="nav-tab ai-tab">
          <FaRobot />
          <span>AI</span>
        </div>
      </nav>

      {/* RIGHT */}
      <div className="navbar-right" ref={menuRef}>
        <button
          className="more-btn"
          onClick={() => setOpen((o) => !o)}
          aria-label="More options"
        >
          <FiMoreVertical />
        </button>

        {open && (
          <div className="dropdown">
            <div className="dropdown-item" onClick={openNewTerminal}>
              <FiTerminal /> <span>New Terminal</span>
            </div>

            <div className="dropdown-item" onClick={closeAllTerminals}>
              <FiTerminal /> <span>Close All Terminals</span>
            </div>

            <div
              className="dropdown-item"
              onClick={() => window.location.reload()}
            >
              <FiRefreshCcw /> <span>Reload Workspace</span>
            </div>

            <div
              className="dropdown-item"
              onClick={() => navigate("/dashboard")}
            >
              <FiHome /> <span>Dashboard</span>
            </div>

            <div className="dropdown-separator" />

            <div
              className="dropdown-item danger"
              onClick={() => {
                logout();
                navigate("/");
              }}
            >
              <FiLogOut /> <span>Logout</span>
            </div>
          </div>
        )}
      </div>
    </header>
  );
}
import { FiFilePlus, FiFolderPlus } from "react-icons/fi";
import FileExplorer from "../explorer/FileExplorer";
import { useWorkspace } from "../../context/WorkspaceContext";
import "../../styles/sidebar.css";

export default function Sidebar() {
  const { setCreateRequest, currentWorkspace } = useWorkspace();

  return (
    <aside className="sidebar">
      {/* HEADER */}
      <div className="sidebar-header">
        <span className="sidebar-title">EXPLORER</span>

        <div className="sidebar-header-actions">
          <button
            title="New File"
            onClick={() =>
              setCreateRequest({ type: "file", parent: "" })
            }
          >
            <FiFilePlus />
          </button>

          <button
            title="New Folder"
            onClick={() =>
              setCreateRequest({ type: "folder", parent: "" })
            }
          >
            <FiFolderPlus />
          </button>
        </div>
      </div>

      {/* WORKSPACE */}
      <div className="workspace-name">
        <span className="workspace-icon">üìÅ</span>
         {currentWorkspace?.name || "Loading..."}
      </div>

      {/* TREE */}
      <div className="sidebar-tree">
        <FileExplorer />
      </div>
    </aside>
  );
}
import "../../styles/preview.css";

export default function LivePreview({ url, activeFile }) {
  if (!url || !activeFile?.endsWith(".html")) return null;

  return (
    <iframe
      key={url} // üî• forces refresh when url changes
      src={url}
      className="live-preview"
      sandbox="allow-scripts allow-same-origin"
      title="Live Preview"
    />
  );
}
import { useEffect, useRef } from "react";
import { Terminal } from "xterm";
import "xterm/css/xterm.css";
import { useWorkspace } from "../../context/WorkspaceContext";
import "../../styles/terminal.css";

export default function TerminalPanel() {
  const { socketRef, activeTerminal } = useWorkspace();
  const containerRef = useRef(null);
  const termRef = useRef(null);

  useEffect(() => {
    if (!activeTerminal || !socketRef.current) return;

    // Create terminal once
    if (!termRef.current) {
      termRef.current = new Terminal({
        theme: { background: "#1e1e1e" },
        fontSize: 13,
        cursorBlink: true,
        convertEol: true,
      });

      termRef.current.onData((data) => {
        socketRef.current.send(
          JSON.stringify({
            type: "input",
            terminalId: activeTerminal,
            data,
          })
        );
      });
    }

    // Mount terminal
    if (containerRef.current) {
      containerRef.current.innerHTML = "";
      termRef.current.open(containerRef.current);
      termRef.current.focus();
    }

    // Listen for backend output
    const handler = (e) => {
      const msg = e.detail;
      if (msg.terminalId === activeTerminal) {
        termRef.current.write(msg.data);
      }
    };

    window.addEventListener("terminal-output", handler);

    return () => {
      window.removeEventListener("terminal-output", handler);
    };
  }, [activeTerminal]);

  return <div ref={containerRef} className="terminal-panel" />;
}
import "../../styles/terminal.css";
import { useWorkspace } from "../../context/WorkspaceContext";

export default function TerminalTabs() {
  const {
    terminals,
    activeTerminal,
    setActiveTerminal,
    killTerminal,
  } = useWorkspace();

  if (!terminals.length) return null;

  return (
    <div className="terminal-tabs">
      {terminals.map((t, i) => (
        <div
          key={t.id}
          className={`terminal-tab ${
            activeTerminal === t.id ? "active" : ""
          }`}
          onClick={() => setActiveTerminal(t.id)}
        >
          Terminal {i + 1}
          <span
            className="close-btn"
            onClick={(e) => {
              e.stopPropagation();
              killTerminal(t.id);
            }}
          >
            ‚úï
          </span>
        </div>
      ))}
    </div>
  );
}
import Clogo from '../assets/Clogo.png';
import CppLogo from '../assets/cpplogo.png';
import PythonLogo from '../assets/pythonlogo.png';
import JavaLogo from '../assets/javalogo.png';
import JsLogo from '../assets/Jslogo.png';
import HTMLlogo from '../assets/HTMLLogo.png';
import CSSlogo from '../assets/CSSLogo.png';


export const LANGUAGE_META = {
  cpp: {
    label: "C++",
    icon: CppLogo,
    color: "#00599C",
    monaco: "cpp",
  },
  c: {
    label: "C",
    icon: Clogo,
    color: "#A8B9CC",
    monaco: "c",
  },
  py: {
    label: "Python",
    icon: PythonLogo,
    color: "#3776AB",
    monaco: "python",
  },
  java: {
    label: "Java",
    icon: JavaLogo,
    color: "#ED8B00",
    monaco: "java",
  },
  js: {
    label: "JavaScript",
    icon: JsLogo,
    color: "#F7DF1E",
    monaco: "javascript",
  },
  html: {
    label: "HTML",
    icon: HTMLlogo,
    color: "#E34F26",
    monaco: "html",
  },
  css: {
    label: "CSS",
    icon: CSSlogo,
    color: "#1572B6",
    monaco: "css",
  },
};
import { createContext, useContext, useEffect, useState } from "react";
import { jwtDecode } from "jwt-decode";


const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [token, setToken] = useState(
    localStorage.getItem("token")
  );
  const [user, setUser] = useState(null);

  useEffect(() => {
    if (token) {
      const decoded = jwtDecode(token);
      setUser({ id: decoded.id });
    }
  }, [token]);

  const login = (token) => {
    localStorage.setItem("token", token);
    setToken(token);
  };

  const logout = () => {
    localStorage.removeItem("token");
    setToken(null);
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ token, user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => useContext(AuthContext);
import {
  createContext,
  useContext,
  useEffect,
  useRef,
  useState,
  useCallback,
} from "react";
import * as fileApi from "../services/fileApi";
import { buildTree } from "../utils/buildTree";

const WorkspaceContext = createContext();

const safeTerminalId = (id) =>
  "term_" + id.replace(/[^a-zA-Z0-9_-]/g, "_");

export function WorkspaceProvider({ userId, workspaceId, children }) {
  /* ================= FILE STATE ================= */

  const [tree, setTree] = useState(null);
  const [openTabs, setOpenTabs] = useState([]);
  const [activeFile, setActiveFile] = useState(null);
  const [fileContents, setFileContents] = useState({});
  const [dirtyFiles, setDirtyFiles] = useState(new Set());
  const [previewUrl, setPreviewUrl] = useState(null);

  const [createRequest, setCreateRequest] = useState(null);
  const [currentWorkspace, setCurrentWorkspace] = useState(null);
  const [currentProject, setCurrentProject] = useState(workspaceId);

  /* ================= TERMINAL ================= */

  const [showTerminal, setShowTerminal] = useState(false);
  const [terminals, setTerminals] = useState([]);
  const [activeTerminal, setActiveTerminal] = useState(null);

  const socketRef = useRef(null);
  const wsReadyRef = useRef(false);
  const pendingCreateRef = useRef(null);
  const pendingRunRef = useRef(null);

  /* ================= AUTOSAVE ================= */

  const SAVE_DELAY = 800;
  const saveTimersRef = useRef({});
  const fileContentsRef = useRef({});

  useEffect(() => {
    fileContentsRef.current = fileContents;
  }, [fileContents]);

  /* ================= WEBSOCKET ================= */

  useEffect(() => {
    if (!userId || !workspaceId) return;

    const token = localStorage.getItem("token");
    const ws = new WebSocket(`ws://localhost:5000?token=${token}`);

    socketRef.current = ws;

    ws.onopen = () => {
      wsReadyRef.current = true;

      if (pendingCreateRef.current) {
        ws.send(JSON.stringify(pendingCreateRef.current));
        pendingCreateRef.current = null;
      }
    };

    ws.onmessage = (e) => {
      const msg = JSON.parse(e.data);

      if (msg.type === "output") {
        window.dispatchEvent(
          new CustomEvent("terminal-output", { detail: msg })
        );
      }

      if (msg.type === "created") {
        setTerminals((prev) =>
          prev.some((t) => t.id === msg.terminalId)
            ? prev
            : [...prev, { id: msg.terminalId }]
        );

        setActiveTerminal(msg.terminalId);

        if (pendingRunRef.current) {
          ws.send(
            JSON.stringify({
              type: "input",
              terminalId: msg.terminalId,
              data: pendingRunRef.current,
            })
          );
          pendingRunRef.current = null;
        }
      }
    };

    return () => ws.close();
  }, [userId, workspaceId]);

  const sendWS = (payload) => {
    if (socketRef.current?.readyState === WebSocket.OPEN) {
      socketRef.current.send(JSON.stringify(payload));
    }
  };

  /* ================= TERMINAL ACTIONS ================= */

  const createTerminal = (terminalId) => {
    const payload = {
      type: "create",
      terminalId,
      userId,
      workspaceId,
    };

    if (!wsReadyRef.current) {
      pendingCreateRef.current = payload;
      return;
    }

    sendWS(payload);
  };

  const openNewTerminal = () => {
    setShowTerminal(true);
    createTerminal(`term_${Date.now()}`);
  };

  const killTerminal = (terminalId) => {
    sendWS({ type: "kill", terminalId });
    setTerminals((prev) => prev.filter((t) => t.id !== terminalId));
    if (activeTerminal === terminalId) setActiveTerminal(null);
  };

  /* ================= LOAD WORKSPACE ================= */

  const loadWorkspace = useCallback(async () => {
    if (!workspaceId) return;

    try {
      const nodes = await fileApi.loadTree(workspaceId);
      setTree(buildTree(nodes));
    } catch (err) {
      console.error("Failed to load workspace", err);
      setTree({ name: workspaceId, type: "folder", children: [] });
    }
  }, [workspaceId]);

  useEffect(() => {
    loadWorkspace();
  }, [loadWorkspace]);

  /* ================= CREATE REQUEST ================= */

  useEffect(() => {
    if (!createRequest) return;

    const { type, parent, name } = createRequest;
    if (!name) return;

    (async () => {
      if (type === "file") await addFile(parent, name);
      else await addFolder(parent, name);
      setCreateRequest(null);
    })();
  }, [createRequest]);

  /* ================= FILE SYSTEM ================= */

  const addFile = async (parentPath, name) => {
    const path = parentPath ? `${parentPath}/${name}` : name;
    await fileApi.createFile(userId, workspaceId, path);
    await loadWorkspace();
    await openFile(path);
  };

  const addFolder = async (parentPath, name) => {
    const path = parentPath ? `${parentPath}/${name}` : name;
    await fileApi.createFolder(userId, workspaceId, path);
    await loadWorkspace();
  };

  const openFile = async (path) => {
    setOpenTabs((prev) =>
      prev.includes(path) ? prev : [...prev, path]
    );

    setActiveFile(path);

    if (fileContentsRef.current[path] !== undefined) return;

    const content = await fileApi.readFile(userId, workspaceId, path);

    setFileContents((prev) => ({
      ...prev,
      [path]: content || "",
    }));
  };

  const updateContent = (path, content) => {
    setFileContents((prev) => ({
      ...prev,
      [path]: content,
    }));

    setDirtyFiles((prev) => {
      const s = new Set(prev);
      s.add(path);
      return s;
    });

    clearTimeout(saveTimersRef.current[path]);

    saveTimersRef.current[path] = setTimeout(async () => {
      try {
        await fileApi.saveFile(
          userId,
          workspaceId,
          path,
          content
        );

        setDirtyFiles((prev) => {
          const s = new Set(prev);
          s.delete(path);
          return s;
        });
      } catch (e) {
        console.error("Save failed", e);
      }
    }, SAVE_DELAY);
  };

  const closeTab = (path) => {
    setOpenTabs((prev) => prev.filter((t) => t !== path));
    if (activeFile === path) setActiveFile(null);
  };

  const renameNode = async (oldPath, newName) => {
    const newPath = oldPath
      .split("/")
      .slice(0, -1)
      .concat(newName)
      .join("/");

    await fileApi.renameNode(userId, workspaceId, oldPath, newPath);
    await loadWorkspace();
  };

  const deleteNode = async (path) => {
    await fileApi.deleteNode(userId, workspaceId, path);
    await loadWorkspace();
  };

  /* ================= RUN FILE ================= */

  const runCode = async () => {
    if (!activeFile) return;

    setPreviewUrl(null);
    setShowTerminal(true);

    await fileApi.saveFile(
      userId,
      workspaceId,
      activeFile,
      fileContentsRef.current[activeFile] || ""
    );

    const terminalId = safeTerminalId(activeFile);
    const file = `/workspace/${activeFile}`;

    let command = "";

    if (activeFile.endsWith(".py"))
      command = `python3 "${file}"`;
    else if (activeFile.endsWith(".js"))
      command = `node "${file}"`;
    else if (activeFile.endsWith(".cpp"))
      command = `g++ "${file}" -o /workspace/a.out && /workspace/a.out`;
    else if (activeFile.endsWith(".c"))
      command = `gcc "${file}" -o /workspace/a.out && /workspace/a.out`;
    else if (activeFile.endsWith(".java")) {
      const dir = activeFile.split("/").slice(0, -1).join("/");
      const cls = activeFile.split("/").pop().replace(".java", "");
      command = `cd /workspace/${dir} && javac ${cls}.java && java ${cls}`;
    } else return;

    if (!terminals.find((t) => t.id === terminalId)) {
      pendingRunRef.current = command + "\n";
      createTerminal(terminalId);
      return;
    }

    setActiveTerminal(terminalId);
    sendWS({ type: "input", terminalId, data: command + "\n" });
  };

  /* ================= RUN PROJECT ================= */

  const runProject = async () => {
    setShowTerminal(true);

    const token = localStorage.getItem("token");

    const res = await fetch("http://localhost:5000/api/run", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ workspaceId }),
    });

    const data = await res.json();

    if (data.preview) {
      setPreviewUrl(data.preview);
    }
  };

  /* ================= PREVIEW ================= */

  const refreshPreview = async () => {
    if (!activeFile?.endsWith(".html")) return;

    await fileApi.saveFile(
      userId,
      workspaceId,
      activeFile,
      fileContentsRef.current[activeFile] || ""
    );

    const safePath = encodeURI(activeFile);

    setPreviewUrl(
      `http://localhost:5000/preview/${userId}/${workspaceId}/${safePath}?t=${Date.now()}`
    );
  };

  useEffect(() => {
    if (!activeFile?.endsWith(".html")) {
      setPreviewUrl(null);
    }
  }, [activeFile]);

  /* ================= CONTEXT ================= */

  return (
    <WorkspaceContext.Provider
      value={{
        tree,
        openTabs,
        activeFile,
        fileContents,
        previewUrl,
        terminals,
        activeTerminal,
        setActiveTerminal,
        createTerminal,
        killTerminal,
        socketRef,
        addFile,
        addFolder,
        openFile,
        updateContent,
        renameNode,
        deleteNode,
        closeTab,
        runCode,
        runProject,
        dirtyFiles,
        createRequest,
        setCreateRequest,
        currentProject,
        setCurrentProject,
        openNewTerminal,
        showTerminal,
        setShowTerminal,
        currentWorkspace,
        setCurrentWorkspace,
        refreshPreview,
      }}
    >
      {children}
    </WorkspaceContext.Provider>
  );
}

export const useWorkspace = () => useContext(WorkspaceContext);
import { useEffect, useState, useRef } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../context/AuthContext";
import {
  listWorkspaces,
  createWorkspace,
  deleteWorkspace,
  renameWorkspace,
  duplicateWorkspace,
  pinWorkspace,
} from "../services/workspaceApi";
import "../styles/dashboard.css";

export default function Dashboard() {
  const { token } = useAuth();
  const navigate = useNavigate();

  const [workspaces, setWorkspaces] = useState([]);
  const [search, setSearch] = useState("");
  const [newName, setNewName] = useState("");

  const [showSearch, setShowSearch] = useState(false);
  const [showCreate, setShowCreate] = useState(false);

  const [menuOpen, setMenuOpen] = useState(null);
  const [renamingId, setRenamingId] = useState(null);
  const [renameValue, setRenameValue] = useState("");

  const searchRef = useRef(null);
  const createRef = useRef(null);

  useEffect(() => {
    listWorkspaces(token).then(setWorkspaces);
  }, [token]);

  useEffect(() => {
    if (showSearch) searchRef.current?.focus();
    if (showCreate) createRef.current?.focus();
  }, [showSearch, showCreate]);

  const filtered = workspaces.filter((w) =>
    w.name.toLowerCase().includes(search.toLowerCase())
  );

  const create = async () => {
    if (!newName.trim()) return;
    const ws = await createWorkspace(token, newName.trim());
    navigate(`/workspace/${ws._id}`);
  };

  const submitRename = async (ws) => {
    if (!renameValue.trim()) {
      setRenamingId(null);
      return;
    }
    const updated = await renameWorkspace(token, ws._id, renameValue);
    setWorkspaces((p) =>
      p.map((w) => (w._id === ws._id ? updated : w))
    );
    setRenamingId(null);
  };

  return (
    <div className="dashboard">
      {/* HEADER */}
      <header className="dashboard-header">
        <img src="/Nlogo.png" className="logo" alt="CodeWhisper" />

        <div className="actions">
          {/* SEARCH */}
          {!showSearch ? (
            <button
              className="icon-btn"
              onClick={() => setShowSearch(true)}
            >
              üîç
            </button>
          ) : (
            <input
              ref={searchRef}
              className="search-input"
              placeholder="Search workspaces..."
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              onBlur={() => setShowSearch(false)}
            />
          )}

          {/* CREATE */}
          {!showCreate ? (
            <button
              className="create-pill"
              onClick={() => setShowCreate(true)}
            >
              + Create Workspace
            </button>
          ) : (
            <div className="create-inline">
              <input
                ref={createRef}
                placeholder="Workspace name"
                value={newName}
                onChange={(e) => setNewName(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && create()}
                onBlur={() => setShowCreate(false)}
              />
              <button onClick={create}>Create</button>
            </div>
          )}
        </div>
      </header>

      {/* GRID */}
      <section className="workspace-grid">
        {filtered.map((ws) => (
          <div key={ws._id} className="workspace-card">
            <div
              className="card-main"
              onClick={() => navigate(`/workspace/${ws._id}`)}
            >
              <span className="folder">üìÅ</span>

              {renamingId === ws._id ? (
                <input
                  className="rename-input"
                  autoFocus
                  value={renameValue}
                  onClick={(e) => e.stopPropagation()}
                  onChange={(e) => setRenameValue(e.target.value)}
                  onBlur={() => submitRename(ws)}
                  onKeyDown={(e) =>
                    e.key === "Enter" && submitRename(ws)
                  }
                />
              ) : (
                <span className="name">{ws.name}</span>
              )}

              {ws.isPinned && <span className="pin">‚≠ê</span>}
            </div>

            {/* MENU */}
            <div className="card-menu">
              <button
                className="kebab"
                onClick={() =>
                  setMenuOpen(menuOpen === ws._id ? null : ws._id)
                }
              >
                ‚ãÆ
              </button>

              {menuOpen === ws._id && (
                <div className="dropdown">
                  <div onClick={() => {
                    setRenamingId(ws._id);
                    setRenameValue(ws.name);
                    setMenuOpen(null);
                  }}>‚úèÔ∏è Rename</div>

                  <div onClick={async () => {
                    const copy = await duplicateWorkspace(token, ws._id);
                    setWorkspaces(p => [copy, ...p]);
                    setMenuOpen(null);
                  }}>üìã Duplicate</div>

                  <div onClick={async () => {
                    const updated = await pinWorkspace(token, ws._id, !ws.isPinned);
                    setWorkspaces(p =>
                      p.map(w => w._id === ws._id ? updated : w)
                    );
                    setMenuOpen(null);
                  }}>
                    ‚≠ê {ws.isPinned ? "Unpin" : "Pin"}
                  </div>

                  <div
                    className="danger"
                    onClick={async () => {
                      await deleteWorkspace(token, ws._id);
                      setWorkspaces(p => p.filter(w => w._id !== ws._id));
                    }}
                  >
                    üóë Delete
                  </div>
                </div>
              )}
            </div>
          </div>
        ))}
      </section>
    </div>
  );
}
import { useNavigate } from "react-router-dom";
import "../styles/landing.css";

export default function Landing() {
  const navigate = useNavigate();

  return (
    <div className="landing">
      {/* NAVBAR */}
      <nav className="landing-nav">
        <img src="/Nlogo.png" alt="CodeWhisper" />
        <button
          className="primary-btn"
          onClick={() => navigate("/login")}
        >
          Enter CodeWhisper
        </button>
      </nav>

      {/* HERO */}
      <section className="hero">
        <h1>
          The <span>AI Workspace</span><br />
          Built for Modern Developers
        </h1>

        <p>
          CodeWhisper is a cloud-native AI coding environment where developers
          think, build, run, and scale software ‚Äî without friction.
        </p>

        <button
          className="primary-btn large"
          onClick={() => navigate("/login")}
        >
          Start Your Journey
        </button>
      </section>

      {/* STATS */}
      <section className="stats">
        <div className="stat">
          <h3>00.00</h3>
          <p>Active Developers</p>
        </div>
        <div className="stat">
          <h3>00.00</h3>
          <p>Total Users</p>
        </div>
        <div className="stat">
          <h3>00.00</h3>
          <p>Projects Created</p>
        </div>
        <div className="stat">
          <h3>00.00</h3>
          <p>Platform Uptime</p>
        </div>
      </section>

      {/* VISION */}
      <section className="vision">
        <h2>Our Vision</h2>
        <p>
          We believe the future of software development is a collaboration
          between human creativity and artificial intelligence. CodeWhisper
          empowers developers to focus on ideas ‚Äî while AI handles execution.
        </p>
      </section>

      {/* USE CASES */}
      <section className="use-cases">
        <h2>Who Is CodeWhisper For?</h2>

        <div className="use-grid">
          <div className="use-card">
            <span>üéì</span>
            <h3>Students</h3>
            <p>Learn faster with AI guidance and live execution.</p>
          </div>

          <div className="use-card">
            <span>üë®‚Äçüíª</span>
            <h3>Developers</h3>
            <p>Build real-world applications with AI-assisted workflows.</p>
          </div>

          <div className="use-card">
            <span>üöÄ</span>
            <h3>Startups</h3>
            <p>Prototype and scale without infrastructure overhead.</p>
          </div>

          <div className="use-card">
            <span>üè´</span>
            <h3>Educators</h3>
            <p>Teach programming interactively with real execution.</p>
          </div>
        </div>
      </section>

      {/* DIFFERENTIATORS */}
      <section className="difference">
        <h2>What Makes CodeWhisper Different?</h2>

        <div className="difference-grid">
          <div className="difference-card">
            <span>üß†</span>
            <h3>AI-Native Core</h3>
            <p>Designed from day one for AI-driven development.</p>
          </div>

          <div className="difference-card">
            <span>‚òÅÔ∏è</span>
            <h3>Zero Setup</h3>
            <p>Run code instantly without local configuration.</p>
          </div>

          <div className="difference-card">
            <span>üéôÔ∏è</span>
            <h3>Voice to Code</h3>
            <p>Convert ideas into code using natural speech.</p>
          </div>

          <div className="difference-card">
            <span>üìÅ</span>
            <h3>Persistent Workspaces</h3>
            <p>Your projects live securely in the cloud.</p>
          </div>
        </div>
      </section>

  <section className="final-cta">
  <div className="final-cta-inner">
    <p className="final-eyebrow">Built for the next generation of developers</p>

    <h2 className="final-title">
      Code with <span>Intelligence</span>,<br />
      not overhead.
    </h2>

    <p className="final-subtitle">
      CodeWhisper removes setup, friction, and guesswork ‚Äî so you can focus on
      building real software with AI at your side.
    </p>

    <div className="final-actions">
      <button className="final-primary">
        Enter CodeWhisper
      </button>
    </div>

    <div className="final-trust">
      Trusted by developers, students, and teams worldwide
    </div>
  </div>
</section>


      {/* FOOTER */}
      <footer className="footer">
        ¬© 2026 CodeWhisper AI ‚Äî Designed for developers
      </footer>
    </div>
  );
}
import { useParams } from "react-router-dom";
import { useAuth } from "../context/AuthContext";
import { WorkspaceProvider, useWorkspace } from "../context/WorkspaceContext";
import { useEffect, useState, useRef } from "react";
import { getWorkspace } from "../services/workspaceApi";

import Sidebar from "../components/layout/Sidebar";
import Navbar from "../components/layout/Navbar";
import EditorTabs from "../components/editor/EditorTabs";
import CodeEditor from "../components/editor/CodeEditor";
import RunBar from "../components/editor/RunBar";
import TerminalTabs from "../components/terminal/TerminalTabs";
import TerminalPanel from "../components/terminal/TerminalPanel";
import LivePreview from "../components/preview/LivePreview";

import "../styles/workspace.css";

/* ================= INNER LAYOUT ================= */

function WorkspaceLayout() {
  const {
    terminals,
    activeTerminal,
    setActiveTerminal,
    killTerminal,
    previewUrl
  } = useWorkspace();

  /* ---------- RESIZABLE SIDEBAR ---------- */
  const [sidebarWidth, setSidebarWidth] = useState(240);
  const resizingSidebar = useRef(false);

  const startSidebarResize = () => {
    resizingSidebar.current = true;
  };

  const resizeSidebar = (e) => {
    if (!resizingSidebar.current) return;
    setSidebarWidth((w) =>
      Math.min(Math.max(w + e.movementX, 180), 420)
    );
  };

  const stopSidebarResize = () => {
    resizingSidebar.current = false;
  };

  /* ---------- RESIZABLE TERMINAL ---------- */
  const [terminalHeight, setTerminalHeight] = useState(240);
  const resizingTerminal = useRef(false);

  const startTerminalResize = () => {
    resizingTerminal.current = true;
  };

  const resizeTerminal = (e) => {
    if (!resizingTerminal.current) return;
    setTerminalHeight((h) =>
      Math.min(Math.max(h - e.movementY, 120), 500)
    );
  };

  const stopTerminalResize = () => {
    resizingTerminal.current = false;
  };

  const showTerminal = terminals.length > 0;

  return (
    <>
      <Navbar />

      <div
        className="workspace"
        onMouseMove={(e) => {
          resizeSidebar(e);
          resizeTerminal(e);
        }}
        onMouseUp={() => {
          stopSidebarResize();
          stopTerminalResize();
        }}
        onMouseLeave={() => {
          stopSidebarResize();
          stopTerminalResize();
        }}
      >
        {/* ---------- SIDEBAR ---------- */}
        <div
          className="sidebar-wrapper"
          style={{ width: sidebarWidth }}
        >
          <Sidebar />
          <div
            className="sidebar-resizer"
            onMouseDown={startSidebarResize}
          />
        </div>

        {/* ---------- MAIN AREA ---------- */}
        <div className="workspace-main">
          <RunBar />
          <EditorTabs />

          <div className="editor-area">
            <CodeEditor />
          </div>

          <LivePreview url={previewUrl} />


          {/* ---------- TERMINAL ---------- */}
          {showTerminal && (
            <div
              className="terminal-section"
              style={{ height: terminalHeight }}
            >
              <div
                className="terminal-resizer"
                onMouseDown={startTerminalResize}
              />

              <TerminalTabs
                terminals={terminals}
                activeTerminal={activeTerminal}
                setActiveTerminal={setActiveTerminal}
                closeTerminal={killTerminal}
              />

              {activeTerminal && (
                <TerminalPanel terminalId={activeTerminal} />
              )}
            </div>
          )}
        </div>
      </div>
    </>
  );
}

/* ================= WORKSPACE META LOADER ================= */

function WorkspaceLoader({ workspaceId, token }) {
  const { setCurrentWorkspace } = useWorkspace();

  useEffect(() => {
    if (!workspaceId || !token) return;

    getWorkspace(token, workspaceId)
      .then(setCurrentWorkspace)
      .catch(() => setCurrentWorkspace(null));
  }, [workspaceId, token]);

  return null;
}

/* ================= PROVIDER WRAPPER ================= */

export default function Workspace() {
  const { id: workspaceId } = useParams();
  const { user, token } = useAuth();

  if (!user) return null;

  return (
    <WorkspaceProvider userId={user.id} workspaceId={workspaceId}>
      <WorkspaceLoader
        workspaceId={workspaceId}
        token={token}
      />
      <WorkspaceLayout />
    </WorkspaceProvider>
  );
}
export async function execute({ userId, workspaceId, command }) {
  await fetch("http://localhost:5000/api/execute", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId, workspaceId, command }),
  });
}
const BASE = "http://localhost:5000/api/files";

/* ================= AUTH HELPERS ================= */

function getAuthHeaders(isJson = true) {
  const token = localStorage.getItem("token");

  if (!token) {
    throw new Error("User not authenticated");
  }

  const headers = {
    Authorization: `Bearer ${token}`,
  };

  if (isJson) {
    headers["Content-Type"] = "application/json";
  }

  return headers;
}

/* ================= LOAD TREE ================= */

export async function loadTree(workspaceId) {
  const res = await fetch(
    `${BASE}/tree?workspaceId=${workspaceId}`,
    {
      headers: getAuthHeaders(false),
    }
  );

  if (!res.ok) {
    throw new Error("Failed to load workspace tree");
  }

  return res.json();
}

/* ================= CREATE FILE / FOLDER ================= */
/* Backend uses ONE route: POST /api/files/create */

export async function createFile(userId, workspaceId, path) {
  const res = await fetch(`${BASE}/create`, {
    method: "POST",
    headers: getAuthHeaders(),
    body: JSON.stringify({
      workspaceId,
      path,
      type: "file",
    }),
  });

  if (!res.ok) {
    throw new Error("Failed to create file");
  }

  return res.json();
}

export async function createFolder(userId, workspaceId, path) {
  const res = await fetch(`${BASE}/create`, {
    method: "POST",
    headers: getAuthHeaders(),
    body: JSON.stringify({
      workspaceId,
      path,
      type: "folder",
    }),
  });

  if (!res.ok) {
    throw new Error("Failed to create folder");
  }

  return res.json();
}

/* ================= READ FILE ================= */

export async function readFile(userId, workspaceId, path) {
  const res = await fetch(
    `${BASE}/read?workspaceId=${workspaceId}&path=${encodeURIComponent(
      path
    )}`,
    {
      headers: getAuthHeaders(false),
    }
  );

  if (!res.ok) {
    throw new Error("Failed to read file");
  }

  const data = await res.json();
  return data.content ?? "";
}

/* ================= SAVE FILE ================= */

export async function saveFile(userId, workspaceId, path, content) {
  const res = await fetch(`${BASE}/save`, {
    method: "PUT",
    headers: getAuthHeaders(),
    body: JSON.stringify({
      workspaceId,
      path,
      content,
    }),
  });

  if (!res.ok) {
    throw new Error("Failed to save file");
  }

  return res.json();
}

/* ================= RENAME FILE / FOLDER ================= */

export async function renameNode(
  userId,
  workspaceId,
  oldPath,
  newPath
) {
  const res = await fetch(`${BASE}/rename`, {
    method: "PUT",
    headers: getAuthHeaders(),
    body: JSON.stringify({
      workspaceId,
      oldPath,
      newPath,
    }),
  });

  if (!res.ok) {
    throw new Error("Failed to rename node");
  }

  return res.json();
}

/* ================= DELETE FILE / FOLDER ================= */

export async function deleteNode(userId, workspaceId, path) {
  const res = await fetch(`${BASE}/delete`, {
    method: "POST",
    headers: getAuthHeaders(),
    body: JSON.stringify({
      workspaceId,
      path,
    }),
  });

  if (!res.ok) {
    throw new Error("Failed to delete node");
  }

  return res.json();
}
export function connectTerminal(userId, workspaceId) {
  const socket = new WebSocket("ws://localhost:5000");

  socket.onopen = () => {
    socket.send(
      JSON.stringify({
        type: "create",
        userId,
        workspaceId,
      })
    );
  };

  return socket;
}
const BASE = "http://localhost:5000/api/workspaces";

const authHeaders = (token) => ({
  Authorization: `Bearer ${token}`,
});

/* LIST */
export async function listWorkspaces(token) {
  const res = await fetch(BASE, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("Failed to load workspaces");
  return res.json();
}

/* CREATE */
export async function createWorkspace(token, name) {
  const res = await fetch(BASE, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...authHeaders(token),
    },
    body: JSON.stringify({ name }),
  });

  if (!res.ok) throw new Error("Failed to create workspace");
  return res.json();
}

/* DELETE */
export async function deleteWorkspace(token, id) {
  const res = await fetch(`${BASE}/${id}`, {
    method: "DELETE",
    headers: authHeaders(token),
  });

  if (!res.ok) throw new Error("Failed to delete workspace");
  return res.json();
}

/* RENAME */
export async function renameWorkspace(token, id, name) {
  const res = await fetch(`${BASE}/${id}/rename`, {
    method: "PATCH",
    headers: {
      "Content-Type": "application/json",
      ...authHeaders(token),
    },
    body: JSON.stringify({ name }),
  });

  if (!res.ok) throw new Error("Failed to rename workspace");
  return res.json();
}

/* DUPLICATE */
export async function duplicateWorkspace(token, id) {
  const res = await fetch(`${BASE}/${id}/duplicate`, {
    method: "POST",
    headers: authHeaders(token),
  });

  if (!res.ok) throw new Error("Failed to duplicate workspace");
  return res.json();
}

/* PIN */
export async function pinWorkspace(token, id, isPinned) {
  const res = await fetch(`${BASE}/${id}/pin`, {
    method: "PATCH",
    headers: {
      "Content-Type": "application/json",
      ...authHeaders(token),
    },
    body: JSON.stringify({ isPinned }),
  });

  if (!res.ok) throw new Error("Failed to pin workspace");
  return res.json();
}

/* GET SINGLE (EDITOR PAGE) */
export async function getWorkspace(token, id) {
  const res = await fetch(`${BASE}/${id}`, {
    headers: authHeaders(token),
  });

  if (!res.ok) throw new Error("Workspace not found");
  return res.json();
}
export function buildTree(nodes) {
  const root = {
    name: "",
    type: "folder",
    children: [],
  };

  const map = { "": root };

  for (const node of nodes) {
    const parts = node.path.split("/");
    let currentPath = "";

    parts.forEach((part, index) => {
      const parentPath = currentPath;
      currentPath = parentPath ? `${parentPath}/${part}` : part;

      if (!map[currentPath]) {
        map[currentPath] = {
          name: part,
          type: index === parts.length - 1 ? node.type : "folder",
          children: [],
        };

        map[parentPath].children.push(map[currentPath]);
      }
    });
  }

  return root;
}
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import Login from "./auth/Login";
import Signup from "./auth/Signup";
import Dashboard from "./pages/Dashboard";
import Workspace from "./pages/Workspace";
import Landing from "./pages/Landing";
import { AuthProvider, useAuth } from "./context/AuthContext";

/* =========================
   PROTECTED ROUTE
========================= */

function ProtectedRoute({ children }) {
  const { token } = useAuth();
  return token ? children : <Navigate to="/login" replace />;
}

/* =========================
   APP
========================= */

export default function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          {/* PUBLIC */}
          <Route path="/" element={<Landing />} />
          <Route path="/login" element={<Login />} />
          <Route path="/signup" element={<Signup />} />

          {/* PROTECTED */}
          <Route
            path="/dashboard"
            element={
              <ProtectedRoute>
                <Dashboard />
              </ProtectedRoute>
            }
          />

          <Route
            path="/workspace/:id"
            element={
              <ProtectedRoute>
                <Workspace />
              </ProtectedRoute>
            }
          />

          {/* FALLBACK */}
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App";
import { WorkspaceProvider } from "./context/WorkspaceContext";

createRoot(document.getElementById("root")).render(
  <WorkspaceProvider>
    <App />
  </WorkspaceProvider>
);
 
This is the frontend code and structure. 
Problems - 
1. On changing the file data is lost and data is also get interchanging for between other.
2. HTML, CSS, JS combine is not working. 
3. Project is not creating like on running the npm install is it not showing the anything inside the folder. 
4. After npm install it lost is ability to give input again. 