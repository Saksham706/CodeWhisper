import mongoose from "mongoose";

export async function connectDB() {
  await mongoose.connect(process.env.MONGO_URI);
  console.log("MongoDB connected");
}
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import User from "../models/User.js";

export async function signup(req, res) {
  try {
    const { firstName, lastName, phone, email, password } = req.body;

    if (!firstName || !lastName || !email || !password) {
      return res
        .status(400)
        .json({ error: "All required fields must be filled" });
    }

    const exists = await User.findOne({ email });
    if (exists) {
      return res.status(409).json({ error: "Email already registered" });
    }

    const passwordHash = await bcrypt.hash(password, 10);

    await User.create({
      firstName,
      lastName,
      phone,
      email,
      passwordHash,
    });

    res.json({ message: "Account created successfully" });
  } catch (err) {
    res.status(500).json({ error: "Signup failed" });
  }
}

export async function login(req, res) {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: "Email and password required" });
    }

    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: "Invalid email or password" });
    }

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) {
      return res.status(401).json({ error: "Invalid email or password" });
    }

    const token = jwt.sign(
      { id: user._id },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    res.json({ token });
  } catch (err) {
    res.status(500).json({ error: "Login failed" });
  }
}

import { execInWorkspace } from "../sandbox/execService.js";
import path from "path";

export const executeCode = async (req, res) => {
  try {
    const { userId, workspaceId, command, stdin } = req.body;

    if (!userId || !workspaceId || !command) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    const workspacePath = path.join(
      process.cwd(),
      "workspaces",
      userId,
      workspaceId
    );

    const result = await execInWorkspace({
      workspaceId,
      workspacePath,
      command,
      stdin,
    });

    res.json(result);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: err.message });
  }
};
import FileNode from "../models/FileNode.js";
import * as fsService from "../services/fileService.js";

/* ========== CREATE FILE / FOLDER ========== */
export async function createNode(req, res) {
  const { workspaceId, path, type } = req.body;

  await FileNode.create({
    workspaceId,
    path,
    type,
    content: type === "file" ? "" : undefined,
  });

  type === "file"
    ? fsService.createFile(req.user.id, workspaceId, path)
    : fsService.createFolder(req.user.id, workspaceId, path);

  res.json({ success: true });
}

/* ========== READ FILE ========== */
export async function readFile(req, res) {
  const { workspaceId, path } = req.query;

  const node = await FileNode.findOne({ workspaceId, path });
  if (!node || node.type !== "file") {
    return res.status(404).json({ error: "File not found" });
  }

  const content = fsService.readFile(
    req.user.id,
    workspaceId,
    path
  );

  res.json({ content });
}

/* ========== SAVE FILE ========== */
export async function saveFile(req, res) {
  try {
    const { workspaceId, path, content } = req.body;

    const node = await FileNode.findOneAndUpdate(
      { workspaceId, path, type: "file" },
      { content },
      { new: true }
    );

    if (!node) {
      return res.status(404).json({ error: "File node not found" });
    }

    fsService.saveFile(req.user.id, workspaceId, path, content);

    res.json({ success: true });
  } catch (err) {
    console.error("SAVE FILE ERROR:", err);
    res.status(500).json({ error: "Failed to save file" });
  }
}



/* ========== RENAME FILE / FOLDER ========== */
export async function renameNode(req, res) {
  const { workspaceId, oldPath, newPath } = req.body;

  await FileNode.updateMany(
    {
      workspaceId,
      path: { $regex: `^${oldPath}` },
    },
    [
      {
        $set: {
          path: {
            $concat: [
              newPath,
              { $substrCP: ["$path", oldPath.length, { $strLenCP: "$path" }] }
            ]
          }
        }
      }
    ]
  );

  fsService.renameNode(
    req.user.id,
    workspaceId,
    oldPath,
    newPath
  );

  res.json({ success: true });
}

/* ========== DELETE FILE / FOLDER ========== */
export async function deleteNode(req, res) {
  const { workspaceId, path } = req.body;

  await FileNode.deleteMany({
    workspaceId,
    path: { $regex: `^${path}` }
  });

  fsService.deleteNode(
    req.user.id,
    workspaceId,
    path
  );

  res.json({ success: true });
}

/* ========== LOAD TREE ========== */
export async function loadTree(req, res) {
  const nodes = await FileNode.find({
    workspaceId: req.query.workspaceId
  }).sort({ path: 1 });

  res.json(nodes);
}
import Workspace from "../models/Workspace.js";
import FileNode from "../models/FileNode.js";
import { ensureWorkspace, deleteWorkspace as deleteWorkspaceFS } from "../services/fileService.js";

/* CREATE */
export async function createWorkspace(req, res) {
  const ws = await Workspace.create({
    userId: req.user.id,
    name: req.body.name,
  });

  ensureWorkspace(req.user.id, ws._id.toString());
  res.json(ws);
}

/* LIST */
export async function listWorkspaces(req, res) {
  const workspaces = await Workspace.find({ userId: req.user.id }).sort({
    isPinned: -1,
    createdAt: -1,
  });
  res.json(workspaces);
}

/* DELETE */
export async function deleteWorkspace(req, res) {
  try {
    // 1️⃣ Delete workspace from MongoDB
    const workspace = await Workspace.findOneAndDelete({
      _id: req.params.id,
      userId: req.user.id,
    });

    if (!workspace) {
      return res.status(404).json({ error: "Workspace not found" });
    }

    // 2️⃣ Delete all files/folders from MongoDB
    await FileNode.deleteMany({
      workspaceId: workspace._id,
    });

    // 3️⃣ Delete workspace folder from filesystem
    deleteWorkspaceFS(req.user.id, workspace._id.toString());

    res.json({ success: true });
  } catch (err) {
    console.error("DELETE WORKSPACE ERROR:", err);
    res.status(500).json({ error: "Failed to delete workspace" });
  }
}

/* RENAME */
export async function renameWorkspace(req, res) {
  const ws = await Workspace.findOneAndUpdate(
    { _id: req.params.id, userId: req.user.id },
    { name: req.body.name },
    { new: true }
  );

  if (!ws) return res.status(404).json({ error: "Not found" });
  res.json(ws);
}

/* DUPLICATE (unchanged) */
export async function duplicateWorkspace(req, res) {
  const old = await Workspace.findOne({
    _id: req.params.id,
    userId: req.user.id,
  });

  if (!old) return res.status(404).json({ error: "Not found" });

  const copy = await Workspace.create({
    userId: req.user.id,
    name: `${old.name} (copy)`,
  });

  ensureWorkspace(req.user.id, copy._id.toString());
  res.json(copy);
}

/* PIN / UNPIN */
export async function togglePin(req, res) {
  const ws = await Workspace.findOneAndUpdate(
    { _id: req.params.id, userId: req.user.id },
    { isPinned: req.body.isPinned },
    { new: true }
  );

  if (!ws) return res.status(404).json({ error: "Not found" });
  res.json(ws);
}
FROM ubuntu:22.04

ENV DEBIAN_FRONTEND=noninteractive

# ---- System deps ----
RUN apt-get update && apt-get install -y \
    curl \
    git \
    gcc \
    g++ \
    python3 \
    python3-pip \
    openjdk-17-jdk \
    maven \
    ca-certificates \
    gnupg \
    lsb-release \
    && rm -rf /var/lib/apt/lists/*

# ---- Install Node.js 18 LTS (OFFICIAL way) ----
RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash - \
    && apt-get install -y nodejs \
    && npm install -g npm@latest \
    && rm -rf /var/lib/apt/lists/*

# ---- Verify installs (debug friendly) ----
RUN node -v && npm -v && java -version && mvn -v && python3 --version

WORKDIR /workspace

CMD ["bash"]
import jwt from "jsonwebtoken";

export function auth(req, res, next) {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return res.sendStatus(401);

  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch {
    res.sendStatus(401);
  }
}
import mongoose from "mongoose";

const fileNodeSchema = new mongoose.Schema({
  workspaceId: { type: mongoose.Schema.Types.ObjectId, ref: "Workspace" },
  path: String,
  type: { type: String, enum: ["file", "folder"] },
  content: String,
}, { timestamps: true });

export default mongoose.model("FileNode", fileNodeSchema);
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  phone: String,
  email: { type: String, unique: true },
  passwordHash: String,
}, { timestamps: true });

export default mongoose.model("User", userSchema);
import mongoose from "mongoose";

const workspaceSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    name: {
      type: String,
      required: true,
    },
    type: {
      type: String,
      default: "general",
    },
    isPinned: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true }
);

export default mongoose.model("Workspace", workspaceSchema);
import fs from "fs";
import path from "path";
import { getImageForWorkspace } from "../sandbox/imageResolver.js";

export function generateCompose(userId, projectName, project) {
  const services = {};

  for (const svc of project.services) {
    services[svc.name] = {
      image: getImageForWorkspace(svc.runtime),
      working_dir: "/app",
      volumes: [
        `./${svc.path}:/app`,
      ],
      command: svc.run,
      ports: svc.port ? [`${svc.port}:${svc.port}`] : [],
      tty: true,
    };
  }

  const compose = {
    version: "3.9",
    services,
  };

  const projectRoot = path.join(
    "workspaces",
    userId,
    projectName
  );

  const composePath = path.join(projectRoot, "docker-compose.yml");

  fs.writeFileSync(
    composePath,
    JSON.stringify(compose, null, 2)
      .replace(/"/g, "")
      .replace(/,/g, "")
  );

  return composePath;
}
import fs from "fs";
import path from "path";

export function detectProject(workspacePath) {
  const files = fs.readdirSync(workspacePath);

  if (files.includes("pom.xml")) {
    return {
      type: "spring-boot",
      run: "mvn spring-boot:run",
      port: 8080,
    };
  }

  if (files.includes("package.json")) {
    const pkg = JSON.parse(
      fs.readFileSync(
        path.join(workspacePath, "package.json"),
        "utf-8"
      )
    );

    if (pkg.scripts?.dev) {
      return {
        type: "node",
        run: "npm install && npm run dev",
        port: 3000,
      };
    }

    if (pkg.scripts?.start) {
      return {
        type: "node",
        run: "npm install && npm start",
        port: 3000,
      };
    }
  }

  if (
    files.includes("requirements.txt") ||
    files.includes("app.py")
  ) {
    return {
      type: "python",
      run: "pip install -r requirements.txt || true && python app.py",
      port: 5000,
    };
  }

  return null;
}
import fs from "fs";
import path from "path";

/**
 * Load project.json from workspace
 */
export function loadProject(userId, projectName) {
  const projectPath = path.join(
    process.cwd(),
    "workspaces",
    userId,
    projectName,
    "project.json"
  );

  if (!fs.existsSync(projectPath)) {
    throw new Error("project.json not found");
  }

  return JSON.parse(fs.readFileSync(projectPath, "utf-8"));
}

/**
 * Validate project services (NO workspace creation here)
 */
export function ensureProjectServices(userId, projectName) {
  const project = loadProject(userId, projectName);

  // ✅ Just validate paths exist
  for (const service of project.services) {
    const servicePath = path.join(
      process.cwd(),
      "workspaces",
      userId,
      projectName,
      service.path
    );

    if (!fs.existsSync(servicePath)) {
      throw new Error(`Service path not found: ${service.path}`);
    }
  }

  return project;
}
import path from "path";
import { exec } from "child_process";
import { loadProject } from "./projectManager.js";
import { generateCompose } from "./composeGenerator.js";

export function runProject(userId, projectName) {
  const project = loadProject(userId, projectName);

  const composePath = generateCompose(
    userId,
    projectName,
    project
  );

  const cwd = path.dirname(composePath);

  exec("docker compose up -d", { cwd }, (err) => {
    if (err) {
      console.error("Compose failed", err);
    }
  });

  return project.services
    .filter(s => s.port)
    .map(s => ({
      service: s.name,
      port: s.port,
      url: `http://localhost:${s.port}`,
    }));
}
import express from "express";
import { signup, login } from "../controllers/authController.js";

const router = express.Router();

router.post("/signup", signup);
router.post("/login", login);

export default router;
import express from "express";
import { executeCode } from "../controllers/executeController.js";

const router = express.Router();


router.post("/", executeCode);

export default router;
import express from "express";
import { auth } from "../middleware/auth.js";
import {
  createNode,
  readFile,
  saveFile,
  renameNode,
  deleteNode,
  loadTree,
} from "../controllers/fileController.js";

const router = express.Router();

router.get("/tree", auth, loadTree);
router.get("/read", auth, readFile);
router.post("/create", auth, createNode);
router.put("/save", auth, saveFile);
router.put("/rename", auth, renameNode);
router.post("/delete", auth, deleteNode);

export default router;
import express from "express";
import path from "path";
import { execInWorkspace } from "../sandbox/execService.js";
import { detectProject } from "../projects/projectDetector.js";
import { auth } from "../middleware/auth.js";

const router = express.Router();

router.post("/", auth, async (req, res) => {
  const { workspaceId } = req.body;

  const workspacePath = path.join(
    process.cwd(),
    process.env.WORKSPACES_ROOT || "workspaces",
    req.user.id,
    workspaceId
  );

  const detected = detectProject(workspacePath);
  if (!detected) {
    return res.status(400).json({
      error: "No runnable project detected",
    });
  }

  await execInWorkspace({
    workspaceId,
    workspacePath,
    command: detected.run,
    detach: true,
  });

  res.json({
    success: true,
    preview: detected.port
      ? `http://localhost:${detected.port}`
      : null,
  });
});

export default router;
import express from "express";
import { auth } from "../middleware/auth.js";
import Workspace from "../models/Workspace.js"; // ✅ REQUIRED
import {
  createWorkspace,
  listWorkspaces,
  deleteWorkspace,
  renameWorkspace,
  duplicateWorkspace,
  togglePin,
} from "../controllers/workspaceController.js";

const router = express.Router();

router.get("/", auth, listWorkspaces);
router.post("/", auth, createWorkspace);
router.delete("/:id", auth, deleteWorkspace);
router.patch("/:id/rename", auth, renameWorkspace);
router.post("/:id/duplicate", auth, duplicateWorkspace);
router.patch("/:id/pin", auth, togglePin);

/* GET SINGLE WORKSPACE (FOR EDITOR PAGE) */
router.get("/:id", auth, async (req, res) => {
  const ws = await Workspace.findOne({
    _id: req.params.id,
    userId: req.user.id,
  });

  if (!ws) {
    return res.status(404).json({ error: "Workspace not found" });
  }

  res.json(ws);
});

export default router;
import Docker from "dockerode";
import path from "path";
import { getImageForWorkspace } from "./imageResolver.js";
import {
  registerContainer,
  getContainerEntry,
  touchContainer,
  removeContainer,
} from "./containerRegistry.js";

const docker = new Docker();

export async function getOrCreateContainer({
  workspaceId,
  workspacePath,
}) {
  const existing = getContainerEntry(workspaceId);
  if (existing) {
    touchContainer(workspaceId);
    return existing.container;
  }

  const image = getImageForWorkspace();

  const container = await docker.createContainer({
    Image: image,
    Tty: true,
    OpenStdin: true,
    Cmd: ["bash"],
    WorkingDir: "/workspace",
    HostConfig: {
      Binds: [`${workspacePath}:/workspace`],
      Memory: 1024 * 1024 * 1024, // 1GB
      CpuShares: 512,
      PidsLimit: 256,
    },
  });

  await container.start();
  registerContainer(workspaceId, container);

  return container;
}

export async function stopAndRemoveContainer(workspaceId) {
  const entry = getContainerEntry(workspaceId);
  if (!entry) return;

  try {
    await entry.container.stop({ t: 5 });
  } catch {}

  try {
    await entry.container.remove({ force: true });
  } catch {}

  removeContainer(workspaceId);
}
import { getAllContainers } from "./containerRegistry.js";
import { stopAndRemoveContainer } from "./containerManager.js";

const IDLE_TIMEOUT =
  Number(process.env.CONTAINER_IDLE_TIMEOUT) ||
  15 * 60 * 1000;

export function startContainerReaper() {
  setInterval(async () => {
    const now = Date.now();

    for (const [workspaceId, entry] of getAllContainers()) {
      if (now - entry.lastUsed > IDLE_TIMEOUT) {
        console.log(`[REAPER] Stopping idle container: ${workspaceId}`);
        await stopAndRemoveContainer(workspaceId);
      }
    }
  }, 60 * 1000);
}
const containers = new Map();
/*
 workspaceId -> {
   container,
   lastUsed: number
 }
*/

export function registerContainer(workspaceId, container) {
  containers.set(workspaceId, {
    container,
    lastUsed: Date.now(),
  });
}

export function touchContainer(workspaceId) {
  const entry = containers.get(workspaceId);
  if (entry) entry.lastUsed = Date.now();
}

export function getContainerEntry(workspaceId) {
  return containers.get(workspaceId);
}

export function removeContainer(workspaceId) {
  containers.delete(workspaceId);
}

export function getAllContainers() {
  return containers;
}
import { getOrCreateContainer } from "./containerManager.js";
import { touchContainer } from "./containerRegistry.js";

export async function execInWorkspace({
  workspaceId,
  workspacePath,
  command,
  detach = false,
}) {
  const container = await getOrCreateContainer({
    workspaceId,
    workspacePath,
  });

  touchContainer(workspaceId);

  const exec = await container.exec({
    Cmd: ["bash", "-lc", command],
    AttachStdout: !detach,
    AttachStderr: !detach,
    Detach: detach,
    WorkingDir: "/workspace",
  });

  if (detach) {
    await exec.start({ Detach: true });
    return { success: true };
  }

  return await exec.start({ hijack: true });
}

export function getImageForWorkspace() {
  return "CodeWhisper/universal-dev:latest";
}
import fs from "fs";
import path from "path";

const WORKSPACES_ROOT = path.join(process.cwd(), "workspaces");

/* ================= HELPERS ================= */

function safeJoin(base, target) {
  const targetPath = path.resolve(base, target);
  if (!targetPath.startsWith(base)) {
    throw new Error("Invalid path");
  }
  return targetPath;
}

export function ensureWorkspace(userId, workspaceId) {
  const wsPath = path.join(WORKSPACES_ROOT, userId, workspaceId);
  if (!fs.existsSync(wsPath)) {
    fs.mkdirSync(wsPath, { recursive: true });
  }
  return wsPath;
}

/* ================= CREATE ================= */

export function createFile(userId, workspaceId, relativePath) {
  const wsPath = ensureWorkspace(userId, workspaceId);
  const fullPath = safeJoin(wsPath, relativePath);

  fs.mkdirSync(path.dirname(fullPath), { recursive: true });
  if (!fs.existsSync(fullPath)) fs.writeFileSync(fullPath, "");
}

export function createFolder(userId, workspaceId, relativePath) {
  const wsPath = ensureWorkspace(userId, workspaceId);
  const fullPath = safeJoin(wsPath, relativePath);

  fs.mkdirSync(fullPath, { recursive: true });
}

/* ================= READ ================= */

export function readFile(userId, workspaceId, relativePath) {
  const wsPath = ensureWorkspace(userId, workspaceId);
  const fullPath = safeJoin(wsPath, relativePath);

  return fs.existsSync(fullPath)
    ? fs.readFileSync(fullPath, "utf-8")
    : "";
}

/* ================= SAVE ================= */

export function saveFile(userId, workspaceId, relativePath, content) {
  const wsPath = ensureWorkspace(userId, workspaceId);
  const fullPath = safeJoin(wsPath, relativePath);

  fs.mkdirSync(path.dirname(fullPath), { recursive: true });
  fs.writeFileSync(fullPath, content);
}

/* ================= RENAME ================= */

export function renameNode(userId, workspaceId, oldPath, newPath) {
  const wsPath = ensureWorkspace(userId, workspaceId);

  const from = safeJoin(wsPath, oldPath);
  const to = safeJoin(wsPath, newPath);

  fs.mkdirSync(path.dirname(to), { recursive: true });
  fs.renameSync(from, to);
}

/* ================= DELETE ================= */

export function deleteNode(userId, workspaceId, relativePath) {
  const wsPath = ensureWorkspace(userId, workspaceId);
  const fullPath = safeJoin(wsPath, relativePath);

  if (fs.existsSync(fullPath)) {
    fs.rmSync(fullPath, { recursive: true, force: true });
  }
}

/* ================= DELETE WORKSPACE ================= */

export function deleteWorkspace(userId, workspaceId) {
  const wsPath = path.join(WORKSPACES_ROOT, userId, workspaceId);

  if (fs.existsSync(wsPath)) {
    fs.rmSync(wsPath, { recursive: true, force: true });
  }
}
import pty from "node-pty";

export function createDockerPty(containerId) {
  const shell =
    process.platform === "win32" ? "cmd.exe" : "bash";

  const args =
    process.platform === "win32"
      ? ["/c", `docker exec -it ${containerId} bash`]
      : ["-c", `docker exec -it ${containerId} bash`];

  return pty.spawn(shell, args, {
    name: "xterm-color",
    cols: 80,
    rows: 24,
    env: process.env,
  });
}
import dotenv from "dotenv";
dotenv.config();

import express from "express";
import cors from "cors";
import http from "http";
import path from "path";

import { connectDB } from "./config/db.js";
import authRoutes from "./routes/authRoutes.js";
import workspaceRoutes from "./routes/workspaceRoutes.js";
import fileRoutes from "./routes/fileRoutes.js";
import executeRoutes from "./routes/executeRoutes.js";
import runRoutes from "./routes/runRoutes.js";

import { setupTerminalServer } from "./terminalServer.js";
import { startContainerReaper } from "./sandbox/containerReaper.js";

const app = express();

/* ================= CORS (FIXED) ================= */

app.use(
  cors({
    origin: "http://localhost:5173", // frontend URL
    credentials: true,
  })
);

app.use(express.json());

/* ================= INIT ================= */

connectDB();
startContainerReaper();

/* ================= ROUTES ================= */

app.use("/api/auth", authRoutes);
app.use("/api/workspaces", workspaceRoutes);
app.use("/api/files", fileRoutes);
app.use("/api/execute", executeRoutes);
app.use("/api/run", runRoutes);
app.use(
  "/preview",
  express.static(path.join(process.cwd(), "workspaces"))
);




/* ================= SERVER ================= */

const server = http.createServer(app);
setupTerminalServer(server);

server.listen(5000, () =>
  console.log("Backend running on http://localhost:5000")
);
import { WebSocketServer } from "ws";
import path from "path";
import jwt from "jsonwebtoken";

import { getOrCreateContainer } from "./sandbox/containerManager.js";
import { touchContainer } from "./sandbox/containerRegistry.js";
import { createDockerPty } from "./terminal/dockerPty.js";

export function setupTerminalServer(server) {
  const wss = new WebSocketServer({ server });

  wss.on("connection", (ws, req) => {
    /* ================= AUTH ================= */

    const params = new URLSearchParams(
      req.url.replace("/?", "")
    );
    const token = params.get("token");

    let userId = null;

    try {
      const decoded = jwt.verify(
        token,
        process.env.JWT_SECRET
      );
      userId = decoded.id;
    } catch (err) {
      ws.close();
      return;
    }

    /* ================= TERMINALS ================= */

    const terminals = new Map();

    ws.on("message", async (raw) => {
      let msg;
      try {
        msg = JSON.parse(raw.toString());
      } catch {
        return;
      }

      /* ---------- CREATE TERMINAL ---------- */
      if (msg.type === "create") {
        const { terminalId, workspaceId } = msg;

        if (!workspaceId || !terminalId) return;

        const workspacePath = path.join(
          process.cwd(),
          process.env.WORKSPACES_ROOT || "workspaces",
          userId,
          workspaceId
        );

        const container = await getOrCreateContainer({
          workspaceId: `${userId}-${workspaceId}`,
          workspacePath,
        });

        touchContainer(`${userId}-${workspaceId}`);

        const ptyProcess = createDockerPty(container.id);
        terminals.set(terminalId, ptyProcess);

        ptyProcess.onData((data) => {
          ws.send(
            JSON.stringify({
              type: "output",
              terminalId,
              data,
            })
          );
        });

        ws.send(
          JSON.stringify({
            type: "created",
            terminalId,
          })
        );
      }

      /* ---------- INPUT ---------- */
      if (msg.type === "input") {
        terminals.get(msg.terminalId)?.write(msg.data);
      }

      /* ---------- KILL ---------- */
      if (msg.type === "kill") {
        terminals.get(msg.terminalId)?.kill();
        terminals.delete(msg.terminalId);
      }
    });

    ws.on("close", () => {
      terminals.forEach((t) => t.kill());
      terminals.clear();
    });
  });
}
